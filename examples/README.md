# mTLS Examples

This directory contains practical examples of using mTLS certificates generated by the mtls tool.

## Overview

- **caddy/** - Caddy web server with mTLS configuration
- **go-server/** - Go HTTP server with mTLS authentication
- **go-client/** - Go HTTP client that connects to mTLS servers

## Quick Start

### 1. Generate Certificates

From the project root:

```bash
# Create a Root CA
./mtls ca create --batch \
  --cn "Example CA" \
  --org "Example Organization" \
  --country "KR" \
  --key-type rsa4096 \
  --years 10

# Create a server certificate
./mtls cert create --batch \
  --ca ./certs/ca \
  --cn "localhost" \
  --org "Example Server" \
  --dns "localhost,127.0.0.1" \
  --ip "127.0.0.1" \
  --key-type rsa2048 \
  --years 5
```

### 2. Choose Your Server

#### Option A: Go Server (Recommended for Learning)

```bash
cd examples/go-server
go run main.go
```

#### Option B: Caddy Server (Production-Ready)

```bash
cd examples/caddy
./run.sh
```

### 3. Test with the Client

In a new terminal:

```bash
cd examples/go-client
go run main.go
```

## Examples Comparison

| Feature | Go Server | Caddy Server |
|---------|-----------|--------------|
| Setup Complexity | Simple | Simple |
| Configuration | Code-based | Declarative |
| Performance | Good | Excellent |
| Production Ready | ✅ | ✅✅ |
| Customization | Full control | Config-based |
| Hot Reload | No | Yes |
| Best For | Learning, Custom Logic | Production, Standard Servers |

## Architecture

```
┌─────────────┐                    ┌─────────────┐
│             │  mTLS Connection   │             │
│  Go Client  │◄──────────────────►│   Server    │
│             │  (Mutual Auth)     │  (Go/Caddy) │
└─────────────┘                    └─────────────┘
      │                                    │
      │ ┌────────────────┐                │
      └─┤  Client Cert   │                │
        │  + Private Key │                │
        └────────────────┘                │
                                          │
                                ┌─────────▼──────┐
                                │  Server Cert   │
                                │  + Private Key │
                                └────────────────┘
                                          │
                        ┌─────────────────▼─────────────┐
                        │        Trusted CA Cert        │
                        │  (for verifying both sides)   │
                        └───────────────────────────────┘
```

## Testing Scenarios

### Scenario 1: Successful mTLS Connection

Both client and server have valid certificates signed by the same CA.

```bash
# Terminal 1
cd examples/go-server && go run main.go

# Terminal 2
cd examples/go-client && go run main.go
```

✅ Expected: All tests pass

### Scenario 2: Missing Client Certificate

Modify the client to not send a certificate.

```bash
curl https://localhost:8443
```

❌ Expected: Connection refused (no client certificate)

### Scenario 3: Invalid Certificate

Try using a certificate from a different CA.

❌ Expected: TLS handshake fails (certificate verification error)

### Scenario 4: Direct cURL Test

```bash
curl --cert ../../certs/servers/localhost/server-cert.pem \
     --key ../../certs/servers/localhost/server-key.pem \
     --cacert ../../certs/ca/ca-cert.pem \
     https://localhost:8443
```

✅ Expected: Success response from server

## Use Cases

### Development & Testing
- Local development with mTLS
- Integration testing
- API testing with mutual authentication

### Microservices
- Service-to-service authentication
- Zero-trust networking
- Internal API security

### IoT & Edge Computing
- Device authentication
- Secure communication with edge devices
- Certificate-based device identity

### Enterprise Applications
- Internal tools requiring strong authentication
- Admin panels with certificate-based access
- Secure API gateways

## Security Notes

### Best Practices

1. **Certificate Rotation**: Rotate server certificates regularly (1-2 years)
2. **CA Security**: Keep the CA private key extremely secure
3. **Certificate Revocation**: Implement CRL or OCSP for production
4. **Monitoring**: Log certificate expiration dates
5. **Access Control**: Limit who can generate certificates

### What mTLS Provides

- ✅ **Strong Authentication**: Both client and server verify each other
- ✅ **Encrypted Communication**: All traffic is TLS-encrypted
- ✅ **Non-repudiation**: Certificate-based identity
- ✅ **Zero-Trust**: No implicit trust, always verify

### What mTLS Does NOT Provide

- ❌ **Authorization**: You still need to implement access control
- ❌ **Rate Limiting**: Implement separately if needed
- ❌ **DDoS Protection**: Additional measures required
- ❌ **Application Security**: Secure coding practices still necessary

## Troubleshooting

### Port Already in Use

```bash
# Find and kill the process using port 8443
lsof -ti:8443 | xargs kill -9
```

### Certificate Expired

```bash
# Check certificate validity
openssl x509 -in certs/servers/localhost/server-cert.pem -noout -dates
```

### Certificate Path Issues

Make sure you're running commands from the correct directory:

```bash
# For go-server and go-client, run from their respective directories
cd examples/go-server  # or go-client
go run main.go

# Certificate paths are relative: ../../certs/...
```

### TLS Handshake Errors

Common causes:
1. Certificate and CA mismatch
2. Expired certificates
3. Incorrect certificate paths
4. TLS version mismatch

Enable debug logging:

```bash
# For Go programs
GODEBUG=x509roots=1 go run main.go
```

## Advanced Examples

### Custom Certificate Validation

See `go-client/main.go` for examples of:
- Loading certificates
- Configuring TLS
- Custom verification logic

### Multiple Certificates

Generate certificates for different purposes:

```bash
# Admin certificate
./mtls cert create --batch --ca ./certs/ca --cn "admin.local"

# Service certificate
./mtls cert create --batch --ca ./certs/ca --cn "service.local"

# IoT device certificate
./mtls cert create --batch --ca ./certs/ca --cn "device-001"
```

### Certificate-Based Authorization

In your server code:

```go
func authorizeAdmin(r *http.Request) bool {
    if r.TLS == nil || len(r.TLS.PeerCertificates) == 0 {
        return false
    }
    
    cert := r.TLS.PeerCertificates[0]
    
    // Check if certificate has admin role
    for _, org := range cert.Subject.Organization {
        if org == "Admin" {
            return true
        }
    }
    
    return false
}
```

## Resources

- [Go TLS Documentation](https://pkg.go.dev/crypto/tls)
- [Caddy TLS Configuration](https://caddyserver.com/docs/caddyfile/directives/tls)
- [mTLS Best Practices](https://www.cloudflare.com/learning/access-management/what-is-mutual-tls/)

## Contributing

Feel free to add more examples! Some ideas:
- gRPC with mTLS
- WebSocket with mTLS
- Docker container with mTLS
- Kubernetes ingress with mTLS
- nginx configuration
- Python client example
